---
title: "new project"
output: html_document
date: "2025-10-22"
---

## Step 1: Data cleaning and preparation

## 1. Importing the data

Remembering to replace the "?" values ​​in the table with NA using na.strings

```{r}

library(dplyr)

data <- read.csv("adult.csv",sep=',', na.strings = "?")

head(data)


```

```{r}
data_sum_occ <- data %>%
  filter(!is.na(occupation)) %>%
  count(occupation, sort=TRUE)

data_sum_occ
```

## 2. Workclass and occupation columns:

## Handle the missing values

First, let's see how many values ​​are missing in the table.

```{r}
# see for columns separated
stack(sort(colSums(is.na(data)), decreasing = TRUE))
# see how many "NA value" is in the data frame
sum(is.na(data))
# 4262 at total
# 1836 in workclass / 1843 in occupation



```

People over 60 can be considered retired, and those under 18 can be considered to have never worked. But first, let's see if the number of these groups is relevant.

```{r}
# see how many na value is oder than 60
sum(is.na(data$workclass) & data$age >= 60)
# see how many na value is younger than 18
sum(is.na(data$workclass) & data$age <= 18)
# under 18 = / workclass = neverworked / occupation = student
```

```{r}
# see how many na value is oder than 60
sum(is.na(data$occupation) & data$age >= 60)
# see how many na value is younger than 18
sum(is.na(data$occupation) & data$age <= 18)
# under 18 = / workclass = neverworked / occupation = student
```

```{r}
filter(data, is.na(data$occupation), data$age <= 18, !is.na(data$workclass))
# the cworkclass is never-worked for these guys
```

So far I can classify all people under 18 as students who have never worked.

```{r}
#student
data <- data %>%
  mutate(
    workclass  = if_else(age <= 18 & is.na(workclass), "Never-worked", workclass),
    occupation = if_else(age <= 18 & is.na(occupation), "Student", occupation)
  )
```

Since all people over 60 years old do not have workclass and occupation information, we can consider them all as retired.

I'll leave it commented for now, as it doesn't discuss the relationship with the team.

```{r}
#data <- data %>%
#  mutate(
#    workclass <- if_else(age >=60 & is.na(workclass), "Retired", workclass),
#     occupation = if_else(age >=60 & is.na(occupation), "Student", occupation)
#  )
# over 65 male, over 63 female => workclass = retired / occupation = retired
# under 18 => / workclass = neverworked / occupation = student

#retired
data$workclass <- ifelse(
  (data$sex == "Male" & data$age >= 65 & is.na(data$workclass)) |
  (data$sex == "Female" & data$age >= 63 & is.na(data$workclass)),
  "Retired", data$workclass
)
data$occupation <- ifelse(
  (data$sex == "Male" & data$age >= 65 & is.na(data$occupation)) |
  (data$sex == "Female" & data$age >= 63 & is.na(data$occupation)),
  "Retired", data$occupation
)

```

Checking whether variables such as sex, age and education have a correlation with the individual's occupation and work class.

```{r}
#install.packages("rcompanion")
library(rcompanion)

chi_square_summary <- function(data, target) {
  results <- data.frame(var = character(), p_value = numeric(), cramerV = numeric(), stringsAsFactors = FALSE)
  
  for (col in names(data)) {
    if (col != target && (is.factor(data[[col]]) || is.character(data[[col]]))) {
      test <- tryCatch({
        tbl <- table(data[[target]], data[[col]])
        list(p = chisq.test(tbl)$p.value,
             cv = cramerV(tbl))
      }, error = function(e) NULL)
      
      if (!is.null(test)) {
        results <- rbind(results, data.frame(var = col, p_value = test$p, cramerV = test$cv))
      }
    }
  }
  results[order(results$cramerV, decreasing = TRUE), ]
}


```

```{r}
chi_square_summary(data, "workclass")
```

```{r}
chi_square_summary(data, "occupation")
```

No other categorical variable actually correlates with workclass. Considering that the vast majority of workclass values ​​are Private, we'll replace the missing values ​​with private.\

I'll leave it commented for now, as it doesn't discuss the relationship with the team.

```{r}
data$workclass[is.na(data$workclass)] <- "Private"
```

We realize that only the variable sex, and perhaps income, can be valid for separating and assembling the rest of the variables in occupation

### Handle the missing values using the most frequent value of each column

```{r}

set.seed(42)
# tabela global para fallback
freq_global <- table(data$occupation, useNA = "no")
probs_global <- freq_global / sum(freq_global)
levels_global <- names(probs_global)

data <- data %>%
  group_by(sex, income) %>%
  group_modify(~{
    df <- .x
    idx_na <- which(is.na(df$occupation))
    if (length(idx_na) > 0) {
      tbl <- table(df$occupation, useNA = "no")
      if (sum(tbl) > 0) {
        probs <- tbl / sum(tbl)
        choices <- names(probs)
        probs_vec <- as.numeric(probs)
      } else {
        # fallback global
        choices <- levels_global
        probs_vec <- as.numeric(probs_global)
      }
      df$occupation[idx_na] <- sample(choices, size = length(idx_na),
                                      replace = TRUE, prob = probs_vec)
    }
    return(df)
  }) %>%
  ungroup()


```

```{r}
data_sum_occ2 <- data %>%
  filter(!is.na(occupation)) %>%
  count(occupation, sort=TRUE)

data_sum_occ2
```

```{r}
sum(is.na(data$workclass))
sum(is.na(data$occupation))

# view rows where the workclass value is NA
data %>%
  filter(is.na(workclass))

# view rows where the occupation value is NA
data %>%
  filter(is.na(occupation))
```

### Check the redundancy of the education and education-num columns : analyse the redundacy and apply the appropriate manipulations

```{r}
#this code here is wrong
edu_relation <- data %>%
  group_by(education, education.num) %>%
  summarise(count = n())

edu_relation

#this is ok
data <- select(data, -education)
#easy to use in modeling

```

```{r}
stack(sort(colSums(is.na(data)), decreasing = TRUE))
#

table_native_country <- count(data, native.country, name = "frequency") %>%
  arrange(desc(frequency))

table_native_country
```

Since the vast majority of native.country values ​​are United States, we will replace the missing values ​​with this value, without making major changes to the table.

```{r}
data[is.na(data[["native.country"]]), "native.country"] <- "United-States"
sum(is.na(data[["native.country"]]))

```

#Categorical variables : Some categorical variables may contain leading or trailing whitespace. Clean these columns.x

```{r}
data %>%
  mutate_if(is.character, trimws)

```

# Step 2: Feature Transformation and Engineering

### Grouping Categories

```{r}
unique(data$native.country)

data$native.country[data$native.country != "United-States"] <- "Other"

data$native.country <- factor(data$native.country)

table(data$native.country)

```

### Target Transformantion

```{r}
unique(data$income)

data$income <- ifelse(data$income == ">50K", 1, 0)

data$income <- as.numeric(data$income)

table(data$income)

```

### Age Discretization

```{r}
summary(data$age)

```

```{r}
data <- data %>%
  mutate(
    AgeGroup = case_when(
      is.na(age) ~ NA_character_,
      age <= 28 ~ "Young",        # 1º quartil
      age <= 48 ~ "Adult",        # between Q1 and Q3
      TRUE ~ "Senior"             # above the Q3
    ),
    AgeGroup = factor(AgeGroup, levels = c("Young", "Adult", "Senior"))
  )

# ver distribuição
table(data$AgeGroup)

```

```{r}
prop.table(table(data$AgeGroup, data$income), margin = 1)
table(data$AgeGroup, data$income)
```

```{r}
data <- data %>%
  mutate(net_capital = capital.gain - capital.loss)
data[,"net_capital"]
```

Spearman's correlation measures the monotonic association between two variables—that is, whether one tends to increase when the other increases, without assuming linearity.

```{r}
# correlação
cor.test(data$net_capital, as.numeric(data$income), method = "spearman")

```

```{r}
summary_capital <- data %>%
  group_by(AgeGroup, income) %>%
  summarise(
    positive = sum(net_capital > 0, na.rm = TRUE),
    zero     = sum(net_capital == 0, na.rm = TRUE),
    negative = sum(net_capital < 0, na.rm = TRUE),
    total    = n(),
    .groups = "drop"
  )

summary_capital
```

```{r}
colnames(data)
```

# Step 3: Visualization and Exploration

```{r}
library(dplyr)
library(ggplot2)
library(scales) # para percentuais e formatação

edu_income <- data %>%
  group_by(education.num) %>%
  summarise(
    n = n(),
    n_high = sum(income == 1),
    prop_high = n_high / n
  ) %>%
  arrange(education.num)

ggplot(edu_income, aes(x = factor(education.num), y = prop_high)) +
  geom_col() +
  geom_text(aes(label = percent(prop_high, accuracy = 0.1)), vjust = -0.5, size = 3) +
  scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0,1), expand = expansion(c(0,0.05))) +
  labs(x = "education.num", y = "Proportion >50K", title = "Proportion of >50K for education-num") +
  theme_minimal()


```

```{r}
ggplot(data, aes(x = factor(income), y = hours.per.week)) +
  geom_violin(trim = TRUE) +
  stat_summary(fun = median, geom = "point", size = 2, color = "black") +
  coord_flip() +
  labs(title = "Violin: hours-per-week por income", x = "Income", y = "Hours per week") +
  theme_minimal()

```

```{r}
ggplot(data, aes(x = marital.status, fill = factor(income))) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  coord_flip() +
  labs(
    x = "Civil State",
    y = "Proportion within the group",
    fill = "Income (0 = ≤50K, 1 = >50K)",
    title = "Impact of marital status on income"
  ) +
  theme_minimal()
```

```{r}
ggplot(data, aes(x = age)) +
  geom_histogram(bins = 30, alpha = 0.8) +
  facet_wrap(~ income) +
  labs(title = "Age distribution by income class", x = "Age", y = "Count") +
  theme_minimal()
```

```{r}
ggplot(data %>% filter(age & hours.per.week), aes(x = age, y = hours.per.week, color = income)) +
  geom_point(alpha = 0.3, size = 0.8) +
  geom_smooth(method = "loess", se = FALSE) +
  labs(title = "Age x hours per week (by income)", x = "Age", y = "Hours per week") +
  theme_minimal()
```

```{r}
library(dplyr)
library(ggplot2)
library(scales)

# Calcular a proporção de pessoas com income = 1 por sexo e nível educacional
edu_sex_income <- data %>%
  group_by(sex, education.num) %>%
  summarise(
    total = n(),
    high_income = sum(income == 1),
    prop_high = high_income / total,
    .groups = "drop"
  )

# Gráfico de barras lado a lado
ggplot(edu_sex_income, aes(x = factor(education.num), y = prop_high, fill = sex)) +
  geom_col(position = "dodge") +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Proportion of people with income >50K by gender and education level.",
    x = "Education Level (education.num)",
    y = "Proportion with income >50K",
    fill = "Sex"
  ) +
  theme_minimal()


```

```{r}
#same grafic that the above. Just a diferent whay to see it
ggplot(edu_sex_income, aes(x = education.num, y = prop_high, color = sex)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Income >50K by sex and education level",
    x = "Education Level",
    y = "Proportion with income >50K",
    color = "Sex"
  ) +
  theme_minimal()
```

```{r}
edu_race_income <- data %>%
  group_by(race, education.num) %>%
  summarise(
    total = n(),
    high_income = sum(income == 1),
    prop_high = high_income / total,
    .groups = "drop"
  )

ggplot(edu_race_income, aes(x = education.num, y = prop_high, color = race)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Income >50K by race and education level",
    x = "Education Level",
    y = "Proportion with income >50K",
    color = "Sex"
  ) +
  theme_minimal()

```

# Step 4: Modeling and Prediction

```{r}
install.packages("fastDummies")
```

```{r}
library(fastDummies)

#verificar colunas categóricas
data_chars <- data %>% select(where(is.character))
cat_cols
```

```{r}
#create dummies variables
data_dummies <- fastDummies::dummy_cols(
  data,
  select_columns = cat_cols,
  remove_first_dummy = TRUE, #evita multicolinearidade
  remove_selected_columns = TRUE #remove the original columns
)
```

```{r}
str(data_dummies)
```

```{r}
install.packages("caret")
```

```{r}
#logistic regression
set.seed(42)

n_rows <- nrow(data_dummies)
train_index <- sample(1:n_rows, 0.8*n_rows)

train <- data_dummies[train_index,]
test <- data_dummies[-train_index,]
```

```{r}
#training the model
#glm - generalized linear model
train$income <- as.factor(train$income)
model_log <- glm(income~ ., data=train,family = binomial(link = "logit"))
summary(model_log)
```

```{r}
pred_prob <- predict(model_log,newdata = test,type="response")
pred_class <- ifelse(pred_prob>0.5,1,0) #prob to class 1 or 0
```

```{r}
# Matriz de confusão
table(Predict = pred_class, Real = test$income)

# Acurácia
accuracy_log <- mean(pred_class == test$income)
accuracy_log
```

Random Forest

```{r}
install.packages("randomForest")
```

```{r}
#random Forest
library(randomForest)

set.seed(42)

#correct names
names(train) <- make.names(names(train))
names(test)  <- make.names(names(test))

model_rf <- randomForest(
  income ~ .,
  data = train,
  ntree = 500, #number of trees
  mtry = (sqrt(ncol(train)-1)), #number of variables tested by division
  importance=TRUE
)
model_rf
```

```{r}
pred_rf_class <- predict(model_rf, newdata = test)
pred_rf_prob <- predict(model_rf, newdata = test, type='prob')[,2]
conf_rf <- table(Predict = pred_rf_class, Real = test$income)
accuracy_rf <- mean(pred_rf == test$income)
accuracy_rf
conf_rf
# varImpPlot(model_rf, main = "Importance of variables")
```

```{r}
cat("Accuracy Logistic:", round(accuracy_log, 3), "\n")
cat("Accuracy Random Forest: ", round(accuracy_rf,3), "\n")
```

```{r}
# For RL
confusionMatrix(as.factor(pred_class), as.factor(test$income), positive = "1")

# Curva ROC e AUC
roc_log <- roc(test$income, pred_prob)
plot(roc_log, col = "blue", main = "Curva ROC - Regressão Logística")
auc_log <- auc(roc_log)
auc_log
```

```{r}
#confusion matrix and AUC for RF
library(caret)
library(pROC)

confusionMatrix(pred_rf_class, as.factor(test$income), positive="1")
roc_rf <- roc(as.numeric(test$income), as.numeric(pred_rf_prob))
plot(roc_rf, col = "darkgreen", main = "ROC Curve - Random Forest")
auc(roc_rf)
```

```{r}
table(pred_rf)
```

```{r}

importance_df <- as.data.frame(importance(model_rf))
top5_vars <- importance_df %>%
  arrange(desc(MeanDecreaseGini)) %>%
  head(5)
top5_vars
```
